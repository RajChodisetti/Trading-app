# Session 01 — 2025-08-22 — Wire stub HTTP polling ingestion

## Part 1 — Development
- **Theme:** Wire stub HTTP polling ingestion
- **Acceptance:** Decision engine polls wire stub via HTTP for real-time events with cursor-based streaming and deterministic testing
- **Rails:** `TRADING_MODE=paper` | `GLOBAL_PAUSE=<true|false>` | wire mode with bounded execution
- **Contracts touched:** Added wire configuration, HTTP polling client, event processing, and wire stub streaming server
- **Changes:**
  - Code: cmd/decision/main.go wire mode integration, cmd/stubs/main.go streaming mode, internal/config/config.go Wire struct
  - Config: config/config.yaml wire section with polling intervals and backoff settings
  - Tests: scripts/run-tests.sh Case 7 for wire mode validation
  - README/Docs: CLAUDE.md updated with wire mode documentation
  - ADRs: N/A

### Implementation notes
- HTTP polling client with exponential backoff and jitter (100ms-10s range)
- Versioned event envelope: `{type, id, ts_utc, payload, v}` for future transport compatibility
- Cursor-based deterministic streaming from fixture data with fixed seed (42)
- Bounded execution via `-max-events` and `-duration-seconds` flags for CI compatibility
- Health check endpoints on wire stub for reliable test orchestration
- Wire event processing converts external events to internal advice/quotes/halts structures
- Comprehensive wire ingestion metrics: polls, events, errors, and startup tracking

---

## Part 2 — Test Run & Edge Cases
### Commands
```bash
# Start wire stub
go run ./cmd/stubs -stream -port 8091 &

# Run decision engine in wire mode
go run ./cmd/decision -wire-mode -wire-url=http://localhost:8091 -max-events=10

# Check wire stub health
curl http://localhost:8091/health

# View wire event stream  
curl http://localhost:8091/stream

# Full test suite with wire mode
make test
```

### Evidence
- ✅ All existing tests pass (Cases 1-6: paused, resumed, after-hours, corroboration, earnings, outbox)
- ✅ Case 7 added: wire_mode ingestion test with deterministic event streaming
- ✅ Wire stub serves fixture events via /stream endpoint with cursor pagination
- ✅ HTTP polling client with health checks and exponential backoff working
- ✅ Wire mode produces identical decisions to fixture mode (deterministic via fixed seed)
- ✅ Bounded execution prevents infinite loops in test environment
- ✅ Wire ingestion metrics captured: startup events and poll counters
- ✅ Process cleanup and port management working in test harness

### Edge Cases Validated
- Wire stub health check timeout prevents test flakiness
- Cursor-based streaming ensures reproducible event ordering
- Bounded execution via max-events and duration-seconds terminates cleanly
- Process cleanup prevents port conflicts between test runs
- Wire mode with global_pause produces same REJECT intents as fixture mode
- Wire event processing correctly converts external events to internal structures
- Error handling for unreachable wire endpoints and malformed responses

## Part 3 — Architectural Notes
### Wire Protocol Design
- **Envelope Structure**: Versioned wrapper supports future transports (WebSocket, NATS)
- **Cursor Semantics**: At-least-once delivery with deterministic ordering per symbol
- **Backoff Strategy**: Exponential + jitter prevents thundering herd on wire endpoint failures
- **Health Integration**: /health endpoint enables orchestration and readiness checks

### Testing Strategy
- **Deterministic Streaming**: Fixed seed (42) ensures wire mode matches fixture results
- **Bounded Execution**: `-max-events=5 -duration-seconds=10` for fast CI completion
- **Process Lifecycle**: Proper stub startup/cleanup prevents port conflicts and zombie processes
- **Decision Equivalence**: Wire mode validates against known fixture outcomes

### Next Session Prep
Wire mode foundation established for Session 8 Slack integration:
- Event processing pipeline handles arbitrary external events
- Configuration system supports new transport types  
- Health checks enable orchestration of external services
- Bounded execution patterns work for long-running processes